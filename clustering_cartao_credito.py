# -*- coding: utf-8 -*-
"""Clustering_cartao_credito.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1OWPJDGavgDo-Dv69Wt8K6tjFLh8yhfRB
"""

import pandas as pd

dataframe = pd.read_csv("/content/drive/MyDrive/Colab Notebooks/Alura/Custering_Extraindo_dados/CC GENERAL.csv")
dataframe.drop(columns=['CUST_ID', 'TENURE'], inplace=True) # inplace=True é para alterar o dataframe original 
dataframe.head()

missing = dataframe.isna().sum()
print(missing)

dataframe.fillna(dataframe.median(), inplace=True)
missing = dataframe.isna().sum()
print(missing)

from sklearn.preprocessing import Normalizer
values = Normalizer().fit_transform(dataframe.values)
print(values)

from sklearn.cluster import KMeans
kmeans =KMeans(n_clusters=5, n_init=10, max_iter=300)
y_pred = kmeans.fit_predict(values)

from sklearn import metrics
labels = kmeans.labels_
silhouette = metrics.silhouette_score(values, labels, metric='euclidean')
print(silhouette)

"""Índice Davies Bouldin"""

dbs = metrics.davies_bouldin_score(values, labels)
print(dbs)

"""Índice Calinski-Harabasz"""

calinski = metrics.calinski_harabasz_score(values, labels)
print(calinski)

def clustering_algorithm(n_clusters, dataset):
    Kmeans = KMeans(n_clusters=n_clusters,  n_init=10, max_iter=300)
    labels = kmeans.fit_predict(dataset)
    s = metrics.silhouette_score(dataset, labels, metric='euclidean')
    dbs = metrics.davies_bouldin_score(dataset, labels)
    calinski = metrics.calinski_harabasz_score(dataset, labels)
    return s, dbs, calinski

s1, dbs1, calinski1 = clustering_algorithm(3, values)
print(s1, dbs1, calinski1)

s2, dbs2, calinski2 = clustering_algorithm(5, values)
print(s2, dbs2, calinski2)

s3, dbs3, calinski3 = clustering_algorithm(20, values)
print(s3, dbs3, calinski3)

"""Validação dos dados """

import numpy as np
random_data = np.random.rand(8950, 16)
s, dbs, calinski = clustering_algorithm(5, random_data)
print(s, dbs, calinski)
print(s2, dbs2, calinski2)

set1, set2, set3 = np.array_split(values, 3)
s1, dbs1, calinski1 = clustering_algorithm(5, set1)
s2, dbs2, calinski2 = clustering_algorithm(5, set2)
s3, dbs3, calinski3 = clustering_algorithm(5, set3)
print(s1, dbs1, calinski1)
print(s2, dbs2, calinski2)
print(s3, dbs3, calinski3)

import matplotlib.pyplot as plt
plt.scatter(dataframe['PURCHASES'], dataframe['PAYMENTS'], c=labels, s=5, cmap='rainbow' )
plt.xlabel("valor total pago")
plt.ylabel("valor total gasto")
plt.show

import seaborn as sns
dataframe["cluster"] = labels
sns.pairplot(dataframe[0:], hue="cluster")

dataframe.groupby("cluster").describe()

centroids = kmeans.cluster_centers_
print(centroids)

"""vericando a variância 

"""

max = len(centroids[0])
for i in range(max):
  print(dataframe.columns.values[i],"\n{:.4f}".format(centroids [:, i].var()))

"""## intepretando os clusters

BALANCE 0.0205

PURCHASES 0.0210

CASH_ADVANCE 0.0280

CREDIT_LIMIT 0.0356

PAYMENTS 0.0301
"""

dataframe.groupby("cluster")["BALANCE"].describe()

description = dataframe.groupby("cluster")["BALANCE","PURCHASES","CASH_ADVANCE","CREDIT_LIMIT","PAYMENTS"]
print(description.mean())

description = dataframe.groupby("cluster")["BALANCE","PURCHASES","CASH_ADVANCE","CREDIT_LIMIT","PAYMENTS"]
n_clients = description.size()
description = description.mean()
description['n_clients'] = n_clients
print(description)

"""## análise manual dos valores obtidos
### Balance 
2: clientes com os maiores valores em gastos

1: clientes com os menores valores em gastos
### Punchases (compras):
3: clientes com maiores valores em compras

2: clientes com menores valores em compras 
### CASH_ADVANCE (saques)
4: clientes com maiores valores em saques

1: clientes com menores valores em saques 
### CREDIT_LIMIT (limite de cartão):
1: (...) maiores valores de limite 

0: (...) menores valores de limite
### PAYMENTS (pagamentos):
4: (...) maiores valores pagos 

1: (...) menores valores pagos 
### Clients
1: maior número de clientes 

0: menor número de clientes 



"""

dataframe.groupby("cluster")["PRC_FULL_PAYMENT"].describe()

